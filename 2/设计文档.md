# 设计文档

## 一.需求说明### 1. 文法说明见第一次词法分析作业### 2. 目标代码说明生成的是四元式，其格式为(op, arg1, arg2, result)
即result := arg1 op arg2
需要指出的是，四元式如果需要用到中间结果，必须用临时变量。

### 3. 优化方案*## 二.详细设计1. 程序结构   ```flow
    st=>start: Start
e=>end: tyr
op1=>operation: My Operation
operation=>subroutine: Read the awesomeness
sub1=>subroutine: My Subroutine
cond=>condition: Yes
io=>inputoutput: 24
st->op1->cond
cond(yes)->io->e
cond(no)->sub1(right)->op1
```
    ```sequence
    张三->李四: 嘿，小四儿, 写博客了没?
    Note right of 李四: 李四愣了一下，说：
    李四-->张三: 忙得吐血，哪有时间写。
    ```

    ```flow
    st=>start: 开始
    e=>end: 结束
    op=>work: 存储到相应的数据结构
    op=>operation: 词法分析
    
    cond=>condition: 确认？

    st->op->cond
    cond(yes)->e
    cond(no)->op
    ```

```flow
st=>start: Improve your
l10n process!
e=>end: Continue to have fun!:
op1=>operation: Go to locize.com:
sub1=>subroutine: Read the awesomeness
cond(align-next=no)=>condition: Interested to
getting started?
io=>inputoutput: Register:
sub2=>subroutine: Read about improving
your localization workflow
op2=>operation: Login: 
cond2=>condition: valid password?
cond3=>condition: reset password?
op3=>operation: send email
sub3=>subroutine: Create a demo project
sub4=>subroutine: Start your real project
io2=>inputoutput: Subscribe
st->op1->sub1->cond
cond(yes)->io->op2->cond2
cond2(no)->cond3
cond3(no,bottom)->op2
cond3(yes)->op3
op3(right)->op2
cond2(yes)->sub3
sub3->sub4->io2->e
cond(no)->sub2(right)->op1
```
 
下面3步循环滚动进行（期望高效率所以分离性差），夹杂对表的操作、出错处理。1）调用词法分析程序，不断地从源程序文件获取词。      将词的属性记录在数据结构中。取词不合法时进行报错、容错处理和跳读。2）对获取的词进行语法分析，匹配具体语法结构。      对应查表、填表操作。填表、语法分析出错时进行报错、容错处理和跳读。3）根据语法结构进行语义检查与分析，生成目标代码。      改变运行栈。语义与语法矛盾时进行报错、容错处理和跳读。主要先介绍一下词法分析，语法分析、语义分析稍简略。

我的词法分析的过程主要如下，把最小单元单词分为如下的几个部分，注意是一直分到最小部分。


| ertw | erwt | erwt |
| --- | --- | --- |
| wert | terw | terw |



|  | 包括 | 对应的字典里的键值 |
| --- | --- | --- |
| 保留字 | "int", "char", "const","if", "else","for","switch", "case","void","return","main" | 100~1000 |
| 常整数、常字符 | 各种常数，出现在各种类型的语句中 | 常整数是99 常字符是98
 |
| 字符串 | 出现在输出语句中 | 97 |
| 标识符 | 用户定义的变量等 | 1000~无穷 |
| 界限符、标点符号、比较符号、运算符 | [ ] ( ) { } ‘ “ , ; + - * /  = > < >= <= == != | 1-50，一一对应 |
2. 类/方法/函数功能

面向过程。无需类。无方法(暂定)，所有的函数，如果不是有正常的返回值需要，都用0和1代表是不是正常返回，如果遇到了异常情况就返回0，否则就是1.

```int lexicalAnalysis(string& str) //词法分析
int ```3. 调用依赖关系【说明各类之间的关系，方法/函数之间的调用关系】4. 符号表管理方案【说明符号表的数据结构、管理算法】

首先是标识符对应的符号表的位置，这个正如词法分析中所写的那样，采用的是一个Map(字典)的数据结构，从1000开始逐个的递增存储。然后根据这个位置，找到符号表它的具体信息。这个是用一个存放集合的vector来存储。其中每一个符号表中的项具有如下的一些内容：

* name: 名字
* link: 指向同一个块中之前定义的那个标识符的位置在哪
* obj: 种类(可以是常整数、常字符、标识符、函数或过程)
* type: 类型(整数、字符、数组)

管理的方法主要是下面几个：

* Add 新增一个
* Modify 修改属性信息
* Find 找到下标为i或者内容为x的符号的信息
* Delete 删除这个符号



5. 存储分配方案> 说明运行时的存储组织及管理方案，运行栈结构
自下而上存储的栈结构。
存储标识符直接存到栈顶，然后对于函数的结构，开辟一个有特殊意义的符号，代表是函数，在运行到的时候放入栈顶，当执行完成的时候每次调用函数时，将新的活动记录压入栈顶每次函数返回（无返回可视作返回空），将栈顶活动记录删除每一个活动记录从下到上依次为：返回地址、前一活动记录基、返回值、参数区、局部数据区

6. 解释执行程序*   	【说明解释执行程序的数据结构，关键算法，及解释执行过程】7. 四元式设计*【对采用的四元式进行详细说明】8. 目标代码生成方案*	【说明代码生成有关的数据结构、关键算法】9. 优化方案

10. 出错处理> 说明出错处理方案、错误信息及含义
尽量都输出错误，允许极少部分的容错
| 对应错误编号  | 错误类型 | 是否容错 |
| --- | --- | --- |
| 1 | 标识符没有定义就使用了 | 否 |
| 2 | 标识符的名字不是允许的范围 | 否 |
| 3 | 定义出现了重复 | 是 |
| 4 | const int 标识符 = 字符 const char 标识符 = 整数  | 否 |
| 5 | 函数的某一个分支没有return值 | 否 |
| 6 | 表达式/项/因子非法 | 否 |
| 7 | 标点符号缺少 | 否 |
| 8 | 数组溢出 | 否 |
| 9 | 函数/过程的调用参数个数和声明个数不匹配 | 否 |
| 10 | 语句的格式错误 | 视情况而定 |


